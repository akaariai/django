import copy
import datetime

from django.core.exceptions import FieldError
from django.db.backends import utils as backend_utils
from django.db.models.constants import LOOKUP_SEP
from django.db.models import fields
from django.db.models.query_utils import refs_aggregate
from django.utils.functional import cached_property


class ExpressionNode(object):
    """
    Base class for all query expressions.
    """

    # Arithmetic connectors
    ADD = '+'
    SUB = '-'
    MUL = '*'
    DIV = '/'
    POW = '^'
    # The following is a quoted % operator - it is quoted because it can be
    # used in strings that also have parameter substitution.
    MOD = '%%'

    # Bitwise operators - note that these are generated by .bitand()
    # and .bitor(), the '&' and '|' are reserved for boolean operator
    # usage.
    BITAND = '&'
    BITOR = '|'

    # aggregate specific fields
    is_summary = False

    def __init__(self, output_field=None):
        self._output_field = output_field
        self.source_expressions = []

    @property
    def col(self):
        return self.source_expressions[0]

    @col.setter
    def col(self, value):
        self.source_expressions[0] = value

    def _combine(self, other, connector, reversed, node=None):
        if isinstance(other, datetime.timedelta):
            return DateModifierNode(self, connector, other)

        if not isinstance(other, ExpressionNode):
            # everything must be some kind of ExpressionNode, so Value is the fallback
            other = Value(other)

        if reversed:
            return Expression(other, connector, self)
        return Expression(self, connector, other)

    def as_sql(self, compiler, connection):
        """
        Responsible for returning a (sql, [params]) tuple to be included
        in the current query.

        Different backends can provide their own implementation, by
        providing an `as_{vendor}` method and patching the Expression:

        ```
        def override_as_sql(self, compiler, connection):
            # custom logic
            return super(ExpressionNode, self).as_sql(compiler, connection)
        setattr(ExpressionNode, 'as_' + connection.vendor, override_as_sql)
        ```

        Arguments:
         * compiler: the query compiler responsible for generating the query.
           Must have a compile method, returning a (sql, [params]) tuple.
           Calling compiler(value) will return a quoted `value`.

         * connection: the database connection used for the current query.

        Returns: (sql, params)
          Where `sql` is a string containing ordered sql parameters to be
          replaced with the elements of the list `params`
        """
        raise NotImplementedError("Subclasses must implement as_sql()")

    @cached_property
    def is_aggregate(self):
        for expr in self.source_expressions:
            if expr and expr.is_aggregate:
                return True
        return False

    def prepare(self, query=None, allow_joins=True, reuse=None, summarize=False):
        """
        Provides the chance to do any preprocessing or validation before being
        added to the query.

        Arguments:
         * query: the backend query implementation
         * allow_joins: boolean allowing or denying use of joins
           in this query
         * reuse: a set of reusable joins for multijoins
         * summarize: a terminal aggregate clause

        Returns: a copy of self prepared for the query
        """
        c = self.copy()
        c.is_summary = summarize
        return c

    @property
    def field(self):
        return self.output_field

    @cached_property
    def output_field(self):
        """
        Returns the output type of this expressions.
        """
        if self._output_field_or_none is None:
            self._resolve_output_field()
            raise FieldError("Cannot resolve expression type, unknown output_field")
        return self._output_field_or_none

    @cached_property
    def _output_field_or_none(self):
        """
        Returns the output field of this expression, or None if no output type
        can be resolved. Note that the 'output_field' property will raise
        FieldError if no type can be resolved, but this attribute allows for
        None values..
        """
        if self._output_field is None:
            self._resolve_output_field()
        return self._output_field

    def _resolve_output_field(self):
        if self._output_field is None:
            sources = self.get_source_fields()
            num_sources = len(sources)
            if num_sources == 0:
                self._output_field = None
            else:
                self._output_field = sources[0]
                for source in sources:
                    if source is not None and not isinstance(self._output_field, source.__class__):
                        raise FieldError(
                            "Expression contains mixed types. You must set output_field")

    def convert_value(self, value, connection):
        """
        Expressions provide their own converters because users have the option
        of manually specifying the output_field which may be a different type
        from the one the database returns.
        """
        field = self.output_field
        internal_type = field.get_internal_type()
        if value is None:
            return value
        elif internal_type == 'FloatField':
            return float(value)
        elif internal_type.endswith('IntegerField'):
            return int(value)
        elif internal_type == 'DecimalField':
            return backend_utils.typecast_decimal(field.format_number(value))
        return value

    def get_lookup(self, lookup):
        return self.output_field.get_lookup(lookup)

    def get_transform(self, name):
        return self.output_field.get_transform(name)

    def relabeled_clone(self, change_map):
        copy = self.copy()
        copy.source_expressions = []
        for expr in self.source_expressions:
            copy.source_expressions.append(expr.relabeled_clone(change_map))
        return copy

    def copy(self):
        c = copy.copy(self)
        c.copied = True
        return c

    def contains_aggregate(self, existing_aggregates):
        """
        Does this expression contain a reference to some of the
        existing aggregates. If so, returns the aggregate and also
        the lookup parts that *weren't* found. So, assume
            exsiting_aggregates = {'max_id': Max('id')}
            self.name = 'max_id'
        then this method will return Max('id') and those parts of the
        name that weren't found. In this case all parts of the name
        are found, so the second part of the return value will be
        ().
        """
        return False, ()

    def refs_field(self, aggregate_types, field_types):
        """
        Helper method for check_aggregate_support on backends
        """
        return any(
            node.refs_field(aggregate_types, field_types)
            for node in self.source_expressions)

    def prepare_database_save(self, field):
        return self

    def get_group_by_cols(self):
        cols = []
        for source in self.source_expressions:
            cols.extend(source.get_group_by_cols())
        return cols

    def get_source_fields(self):
        """
        Returns the underlying field types used by this
        aggregate.
        """
        return [e._output_field_or_none for e in self.source_expressions]

    def __bool__(self):
        """
        For truth value testing.
        """
        return True

    #############
    # OPERATORS #
    #############

    def __add__(self, other):
        return self._combine(other, self.ADD, False)

    def __sub__(self, other):
        return self._combine(other, self.SUB, False)

    def __mul__(self, other):
        return self._combine(other, self.MUL, False)

    def __truediv__(self, other):
        return self._combine(other, self.DIV, False)

    def __div__(self, other):  # Python 2 compatibility
        return type(self).__truediv__(self, other)

    def __mod__(self, other):
        return self._combine(other, self.MOD, False)

    def __pow__(self, other):
        return self._combine(other, self.POW, False)

    def __and__(self, other):
        raise NotImplementedError(
            "Use .bitand() and .bitor() for bitwise logical operations."
        )

    def bitand(self, other):
        return self._combine(other, self.BITAND, False)

    def __or__(self, other):
        raise NotImplementedError(
            "Use .bitand() and .bitor() for bitwise logical operations."
        )

    def bitor(self, other):
        return self._combine(other, self.BITOR, False)

    def __radd__(self, other):
        return self._combine(other, self.ADD, True)

    def __rsub__(self, other):
        return self._combine(other, self.SUB, True)

    def __rmul__(self, other):
        return self._combine(other, self.MUL, True)

    def __rtruediv__(self, other):
        return self._combine(other, self.DIV, True)

    def __rdiv__(self, other):  # Python 2 compatibility
        return type(self).__rtruediv__(self, other)

    def __rmod__(self, other):
        return self._combine(other, self.MOD, True)

    def __rpow__(self, other):
        return self._combine(other, self.POW, True)

    def __rand__(self, other):
        raise NotImplementedError(
            "Use .bitand() and .bitor() for bitwise logical operations."
        )

    def __ror__(self, other):
        raise NotImplementedError(
            "Use .bitand() and .bitor() for bitwise logical operations."
        )


class Expression(ExpressionNode):

    def __init__(self, lhs, connector, rhs, output_field=None):
        super(Expression, self).__init__(output_field=output_field)
        self.connector = connector
        self.source_expressions = [lhs, rhs]

    @property
    def lhs(self):
        return self.source_expressions[0]

    @lhs.setter
    def lhs(self, value):
        self.source_expressions[0] = value

    @property
    def rhs(self):
        return self.source_expressions[1]

    @rhs.setter
    def rhs(self, value):
        self.source_expressions[1] = value

    def as_sql(self, compiler, connection):
        expressions = []
        expression_params = []
        sql, params = compiler.compile(self.lhs)
        expressions.append(sql)
        expression_params.extend(params)
        sql, params = compiler.compile(self.rhs)
        expressions.append(sql)
        expression_params.extend(params)
        # order of precedence
        expression_wrapper = '(%s)'
        sql = connection.ops.combine_expression(self.connector, expressions)
        return expression_wrapper % sql, expression_params

    def prepare(self, query=None, allow_joins=True, reuse=None, summarize=False):
        c = self.copy()
        c.is_summary = summarize
        c.lhs = c.lhs.prepare(query, allow_joins, reuse, summarize)
        c.rhs = c.rhs.prepare(query, allow_joins, reuse, summarize)
        return c

    def contains_aggregate(self, existing_aggregates):
        for node in (self.lhs, self.rhs):
            agg, lookup = node.contains_aggregate(existing_aggregates)
            if agg:
                return agg, lookup
        return False, ()


class DateModifierNode(Expression):
    """
    Node that implements the following syntax:
    filter(end_date__gt=F('start_date') + datetime.timedelta(days=3, seconds=200))

    which translates into:
    POSTGRES:
        WHERE end_date > (start_date + INTERVAL '3 days 200 seconds')

    MYSQL:
        WHERE end_date > (start_date + INTERVAL '3 0:0:200:0' DAY_MICROSECOND)

    ORACLE:
        WHERE end_date > (start_date + INTERVAL '3 00:03:20.000000' DAY(1) TO SECOND(6))

    SQLITE:
        WHERE end_date > django_format_dtdelta(start_date, "+" "3", "200", "0")
        (A custom function is used in order to preserve six digits of fractional
        second information on sqlite, and to format both date and datetime values.)

    Note that microsecond comparisons are not well supported with MySQL, since
    MySQL does not store microsecond information.

    Only adding and subtracting timedeltas is supported, attempts to use other
    operations raise a TypeError.
    """
    def __init__(self, lhs, connector, rhs):
        if not isinstance(rhs, datetime.timedelta):
            raise TypeError('rhs must be a timedelta.')
        if connector not in (self.ADD, self.SUB):
            raise TypeError('Connector must be + or -, not %s' % connector)
        super(DateModifierNode, self).__init__(lhs, connector, Value(rhs))

    def as_sql(self, compiler, connection):
        timedelta = self.rhs.value
        sql, params = compiler.compile(self.lhs)
        if (timedelta.days == timedelta.seconds == timedelta.microseconds == 0):
            return sql, params
        return connection.ops.date_interval_sql(sql, self.connector, timedelta), params


class F(ExpressionNode):
    """
    An expression representing the value of the given field.
    """
    def __init__(self, name):
        """
        Arguments:
         * name: the name of the field this expression references
        """
        super(F, self).__init__()
        self.name = name

    def prepare(self, query=None, allow_joins=True, reuse=None, summarize=False):
        c = self.copy()
        c.is_summary = summarize
        if not allow_joins and LOOKUP_SEP in c.name:
            raise FieldError("Joined field references are not permitted in this query")
        c.setup_cols(query, reuse)
        return c

    def as_sql(self, compiler, connection):
        return compiler.compile(self.col)

    def setup_cols(self, query, reuse):
        if query is None:
            return
        field_list = self.name.split(LOOKUP_SEP)
        if self.name in query.annotations:
            self.source_expressions = [query.annotation_select[self.name]]
        else:
            try:
                field, sources, opts, join_list, path = query.setup_joins(
                    field_list, query.get_meta(),
                    query.get_initial_alias(), reuse)
                self._used_joins = join_list
                targets, _, join_list = query.trim_joins(sources, join_list, path)
                if len(targets) > 1:
                    raise FieldError("Referencing multicolumn fields in expressions "
                                     "isn't supported")
                if reuse is not None:
                    reuse.update(join_list)
                assert self._output_field is None
                self._output_field = sources[0]
                self.source_expressions = [Col(join_list[-1], targets[0], sources[0])]
            except fields.FieldDoesNotExist:
                raise FieldError("Cannot resolve keyword %r into field. "
                                 "Choices are: %s" % (self.name,
                                                      [f.name for f in self.opts.fields]))

    def contains_aggregate(self, existing_aggregates):
        return refs_aggregate(self.name.split(LOOKUP_SEP), existing_aggregates)


class Func(ExpressionNode):
    """
    A SQL function call.
    """
    function = None
    template = '%(function)s(%(expressions)s)'
    arg_joiner = ', '

    def __init__(self, *expressions, **extra):
        output_field = extra.pop('output_field', None)
        super(Func, self).__init__(output_field=output_field)
        self.source_expressions = self._parse_expressions(*expressions)
        self.extra = extra

    def _parse_expressions(self, *expressions):
        return [
            arg if isinstance(arg, ExpressionNode) else F(arg)
            for arg in expressions
        ]

    def prepare(self, query=None, allow_joins=True, reuse=None, summarize=False):
        c = self.copy()
        c.is_summary = summarize
        for pos, arg in enumerate(c.source_expressions):
            c.source_expressions[pos] = arg.prepare(query, allow_joins, reuse, summarize)
        return c

    def as_sql(self, compiler, connection, function=None, template=None):
        sql_parts = []
        params = []
        for arg in self.source_expressions:
            arg_sql, arg_params = compiler.compile(arg)
            sql_parts.append(arg_sql)
            params.extend(arg_params)
        if function is None:
            self.extra['function'] = self.extra.get('function', self.function)
        else:
            self.extra['function'] = function
        self.extra['expressions'] = self.extra['field'] = self.arg_joiner.join(sql_parts)
        template = template or self.extra.get('template', self.template)
        return template % self.extra, params

    def contains_aggregate(self, existing_aggregates):
        for arg in self.source_expressions:
            agg, lookup = arg.contains_aggregate(existing_aggregates)
            if agg:
                return agg, lookup
        return False, ()


class Value(ExpressionNode):
    """
    Represents a wrapped value as a node within an expression
    """
    def __init__(self, value, output_field=None):
        """
        Arguments:
         * value: the value this expression represents. The value will be
           added into the sql parameter list and properly quoted.

         * output_field: the Model Field type that this expression will
           return, such as IntegerField() or CharField().
        """
        super(Value, self).__init__(output_field=output_field)
        self.value = value

    def as_sql(self, compiler, connection):
        return '%s', [self.value]


class Col(ExpressionNode):
    def __init__(self, alias, target, source=None):
        if source is None:
            source = target
        super(Col, self).__init__(output_field=source)
        self.alias, self.target = alias, target

    def as_sql(self, qn, connection):
        return "%s.%s" % (qn(self.alias), qn(self.target.column)), []

    def relabeled_clone(self, relabels):
        return self.__class__(relabels.get(self.alias, self.alias), self.target, self.output_field)

    def get_group_by_cols(self):
        return [(self.alias, self.target.column)]


class Ref(ExpressionNode):
    """
    Reference to column alias of the query. For example, Ref('sum_cost') in
    qs.annotate(sum_cost=Sum('cost')) query.
    """
    def __init__(self, refs, source):
        super(Ref, self).__init__()
        self.source_expressions = [source]
        self.refs = refs

    def relabeled_clone(self, relabels):
        return self

    def as_sql(self, compiler, connection):
        return "%s" % compiler(self.refs), []

    def get_group_by_cols(self):
        return [(None, self.refs)]


class Date(ExpressionNode):
    """
    Add a date selection column.
    """
    def __init__(self, col, lookup_type):
        super(Date, self).__init__(output_field=fields.DateField())
        self.source_expressions = [col]
        self.lookup_type = lookup_type

    def as_sql(self, qn, connection):
        sql, params = self.col.as_sql(qn, connection)
        assert not(params)
        return connection.ops.date_trunc_sql(self.lookup_type, sql), []


class DateTime(ExpressionNode):
    """
    Add a datetime selection column.
    """
    def __init__(self, col, lookup_type, tzname):
        super(DateTime, self).__init__(output_field=fields.DateTimeField())
        self.source_expressions = [col]
        self.lookup_type = lookup_type
        self.tzname = tzname

    def as_sql(self, qn, connection):
        sql, params = self.col.as_sql(qn, connection)
        assert not(params)
        return connection.ops.datetime_trunc_sql(self.lookup_type, sql, self.tzname)
